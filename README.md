# Mirea_3
# Алгоритмы сортировки и поиска

## Описание проекта
Проект содержит реализации основных алгоритмов сортировки и поиска на языках **Python**, **C++** и **Java**.  
Каждый файл представляет отдельную программу, реализующую конкретный алгоритм и демонстрирующую его работу на тестовых данных.  
Все алгоритмы снабжены определениями, пошаговыми описаниями и полными пояснениями по временной и пространственной сложности (ВС).

## Определения
- **Алгоритм сортировки** — способ упорядочивания элементов по возрастанию или убыванию с помощью заданных шагов.
- **Алгоритм поиска** — метод нахождения элемента по ключу в массиве или структуре данных.
- **Асимптотическая временная сложность (Big O)** — приближённая оценка количества операций при росте размера входных данных.
- **Пространственная сложность** — количество дополнительной памяти, необходимое для работы алгоритма.
- **Стабильность сортировки** — свойство алгоритма сохранять относительный порядок равных элементов.
.
├── selection_sort.cpp
├── BubbleSort.java
├── insertion_sort.py
├── merge_sort.cpp
├── ShellSort.java
├── quick_sort.py
├── heap_sort.cpp
├── linear_search.py
├── binary_search.cpp
├── InterpolationSearch.java
└── fibonacci_search.py

---

## Содержание и объяснения

### 1. Selection Sort — `selection_sort.cpp`

**Определение:**  
Сортировка выбором (Selection Sort) — итеративный алгоритм, который на каждом шаге выбирает минимальный элемент из неотсортированной части массива и помещает его в конец уже отсортированной части.

**Как работает (пошагово):**
1. Для индекса `i` от 0 до n-2 найти минимальный элемент в подмассиве `arr[i..n-1]`.
2. Поменять местами `arr[i]` и найденный минимальный элемент.
3. Повторить шаги для следующего `i`.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(n²)
  - Средний: O(n²)
  - Худший: O(n²)
- Пространственная сложность: O(1)  
- Стабильность: **нестабильна**  
- Примечания: подходит для небольших массивов, когда важна простота реализации.

---

### 2. Bubble Sort — `BubbleSort.java`

**Определение:**  
Сортировка обменом (Bubble Sort) — алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке.

**Как работает (пошагово):**
1. Для каждого прохода сравнивать элементы попарно.
2. При необходимости менять местами соседние элементы.
3. После каждого прохода один наибольший элемент «всплывает» в конец массива.
4. Повторять, пока массив не отсортирован.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(n) (если массив отсортирован)
  - Средний: O(n²)
  - Худший: O(n²)
- Пространственная сложность: O(1)  
- Стабильность: **стабильна**  
- Примечания: применяется для демонстрации, не используется для больших наборов данных.

---

### 3. Insertion Sort — `insertion_sort.py`

**Определение:**  
Сортировка вставками (Insertion Sort) — алгоритм, формирующий отсортированную часть массива путём последовательной вставки элементов на правильное место.

**Как работает (пошагово):**
1. Первый элемент считается отсортированным.
2. Для каждого следующего элемента находится позиция в отсортированной части массива.
3. Элементы сдвигаются, чтобы освободить место, и элемент вставляется.
4. Повторять для всех элементов.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(n)
  - Средний: O(n²)
  - Худший: O(n²)
- Пространственная сложность: O(1)  
- Стабильность: **стабильна**  
- Примечания: эффективна для небольших или частично отсортированных массивов.

---

### 4. Merge Sort — `merge_sort.cpp`

**Определение:**  
Сортировка слиянием (Merge Sort) — рекурсивный алгоритм «разделяй и властвуй», делящий массив пополам, сортирующий части и сливающий их обратно в один отсортированный массив.

**Как работает (пошагово):**
1. Разделить массив на две половины.
2. Рекурсивно отсортировать каждую половину.
3. Слить две отсортированные части, сравнивая элементы.
4. Вернуть итоговый отсортированный массив.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(n log n)
  - Средний: O(n log n)
  - Худший: O(n log n)
- Пространственная сложность: O(n)  
- Стабильность: **стабильна**  
- Примечания: удобна для работы с большими объёмами данных, подходит для внешней сортировки.

---

### 5. Shell Sort — `ShellSort.java`

**Определение:**  
Сортировка Шелла (Shell Sort) — улучшение сортировки вставками, использующее переменный шаг для предварительной сортировки элементов, стоящих на определённом расстоянии друг от друга.

**Как работает (пошагово):**
1. Определить начальный шаг `gap` (например, `n/2`).
2. Сортировать элементы, находящиеся на расстоянии `gap`.
3. Уменьшить `gap` и повторить процесс до `gap = 1`.
4. Завершить, когда весь массив отсортирован.

**Пояснения (ВС):**
- Временная сложность: от O(n^(3/2)) до O(n log² n)  
- Пространственная сложность: O(1)  
- Стабильность: **нестабильна**  
- Примечания: эффективность зависит от выбранной последовательности шагов.

---

### 6. Quick Sort — `quick_sort.py`

**Определение:**  
Быстрая сортировка (Quick Sort) — рекурсивный алгоритм, выбирающий опорный элемент (pivot), разделяющий массив на части меньше и больше pivot, и сортирующий их отдельно.

**Как работает (пошагово):**
1. Выбрать опорный элемент.
2. Разделить массив на две части относительно pivot.
3. Рекурсивно отсортировать левую и правую части.
4. Объединить результаты (или просто оставить на месте).

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(n log n)
  - Средний: O(n log n)
  - Худший: O(n²)
- Пространственная сложность: O(log n)  
- Стабильность: **нестабильна**  
- Примечания: очень эффективна на практике при случайном выборе pivot.

---

### 7. Heap Sort — `heap_sort.cpp`

**Определение:**  
Пирамидальная сортировка (Heap Sort) — алгоритм, который использует структуру max-heap (двоичную кучу) для сортировки элементов по возрастанию.

**Как работает (пошагово):**
1. Построить max-heap из массива.
2. Поменять местами корень (максимум) и последний элемент.
3. Уменьшить размер кучи и восстановить свойство max-heap.
4. Повторять, пока все элементы не окажутся на своих местах.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(n log n)
  - Средний: O(n log n)
  - Худший: O(n log n)
- Пространственная сложность: O(1)  
- Стабильность: **нестабильна**  
- Примечания: обеспечивает гарантированную производительность, используется в системах с ограниченной памятью.

---

### 8. Linear Search — `linear_search.py`

**Определение:**  
Последовательный поиск (Linear Search) — метод, который проверяет каждый элемент массива до тех пор, пока не найдёт нужный или не достигнет конца массива.

**Как работает (пошагово):**
1. Начать с первого элемента.
2. Сравнивать каждый элемент с искомым ключом.
3. Если найден — вернуть индекс, иначе продолжить.
4. Вернуть -1, если элемент отсутствует.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(1)
  - Средний: O(n)
  - Худший: O(n)
- Пространственная сложность: O(1)  
- Примечания: простейший метод поиска, не требует сортировки массива.

---

### 9. Binary Search — `binary_search.cpp`

**Определение:**  
Двоичный поиск (Binary Search) — эффективный метод поиска в отсортированном массиве, делящий диапазон поиска пополам на каждой итерации.

**Как работает (пошагово):**
1. Установить границы поиска (`left`, `right`).
2. Найти середину `mid = (left + right) / 2`.
3. Сравнить значение `arr[mid]` с ключом.
4. В зависимости от результата сузить диапазон и повторить шаги.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(1)
  - Средний: O(log n)
  - Худший: O(log n)
- Пространственная сложность: O(1)  
- Примечания: требует предварительно отсортированных данных.

---

### 10. Interpolation Search — `InterpolationSearch.java`

**Определение:**  
Интерполяционный поиск (Interpolation Search) — алгоритм поиска, который вычисляет предполагаемую позицию элемента на основе линейной интерполяции между границами диапазона.

**Как работает (пошагово):**
1. Вычислить индекс `pos` по формуле:  
   `pos = lo + ((hi - lo) * (key - arr[lo])) / (arr[hi] - arr[lo])`
2. Сравнить `arr[pos]` с ключом.
3. Если `arr[pos] < key`, искать справа; если `arr[pos] > key`, искать слева.
4. Повторять, пока диапазон не сузится.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(log log n)
  - Средний: O(log log n)
  - Худший: O(n)
- Пространственная сложность: O(1)  
- Примечания: эффективно при равномерном распределении значений.

---

### 11. Fibonacci Search — `fibonacci_search.py`

**Определение:**  
Поиск по Фибоначчи (Fibonacci Search) — алгоритм, использующий числа Фибоначчи для разделения массива на интервалы при поиске элемента.

**Как работает (пошагово):**
1. Определить минимальное число Фибоначчи `F[m] ≥ n`.
2. Использовать `F[m-2]` и `F[m-1]` для расчёта индексов сравнения.
3. Сравнивать элементы и сдвигать диапазон поиска.
4. Повторять, пока не найден элемент или не останется один элемент.

**Пояснения (ВС):**
- Временная сложность:
  - Лучший: O(1)
  - Средний: O(log n)
  - Худший: O(log n)
- Пространственная сложность: O(1)  
- Примечания: работает только с отсортированными массивами.

---

## Таблица характеристик

| Алгоритм | Тип | Врем. сложность (лучший/средний/худший) | Простр. сложность | Стабильность |
|-----------|------|------------------------------------------|-------------------|---------------|
| Selection Sort | Сортировка | O(n²) / O(n²) / O(n²) | O(1) | Нет |
| Bubble Sort | Сортировка | O(n) / O(n²) / O(n²) | O(1) | Да |
| Insertion Sort | Сортировка | O(n) / O(n²) / O(n²) | O(1) | Да |
| Merge Sort | Сортировка | O(n log n) / O(n log n) / O(n log n) | O(n) | Да |
| Shell Sort | Сортировка | O(n^(3/2)) / O(n log² n) / O(n²) | O(1) | Нет |
| Quick Sort | Сортировка | O(n log n) / O(n log n) / O(n²) | O(log n) | Нет |
| Heap Sort | Сортировка | O(n log n) / O(n log n) / O(n log n) | O(1) | Нет |
| Linear Search | Поиск | O(1) / O(n) / O(n) | O(1) | — |
| Binary Search | Поиск | O(1) / O(log n) / O(log n) | O(1) | — |
| Interpolation Search | Поиск | O(log log n) / O(log log n) / O(n) | O(1) | — |
| Fibonacci Search | Поиск | O(1) / O(log n) / O(log n) | O(1) | — |

---

## Автор
**Александр Руденко**  
группа УИБО-14-24
