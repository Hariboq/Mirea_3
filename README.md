# Mirea_3
# Алгоритмы сортировки и поиска

## Описание проекта
Проект содержит реализации классических алгоритмов сортировки и поиска на языках **Python**, **C++** и **Java**.  
Каждый файл демонстрирует работу конкретного алгоритма, включая его определение, описание принципа действия и пояснения по временной и пространственной сложности.  
Выбрана одна наиболее характерная оценка временной сложности (типичная ситуация на практике).

## Определения
- **Алгоритм сортировки** — процедура упорядочивания элементов массива по возрастанию или убыванию.  
- **Алгоритм поиска** — метод нахождения элемента по ключу в структуре данных.  
- **Временная сложность** — оценка количества операций при типичных входных данных.  
- **Пространственная сложность** — объём дополнительной памяти, требуемой алгоритмом.  
- **Стабильность сортировки** — сохраняет ли алгоритм порядок равных элементов.


---

## Содержание и объяснения

### 1. Selection Sort — `selection_sort.cpp`

**Определение:**  
Сортировка выбором — алгоритм, который находит минимальный элемент в неотсортированной части массива и помещает его в начало.

**Как работает:**
1. Для каждого индекса `i` искать минимальный элемент в диапазоне `i..n-1`.  
2. Менять местами найденный элемент и `arr[i]`.  
3. Повторять, пока весь массив не будет отсортирован.

**Временная сложность:** O(n²)  
**Пространственная сложность:** O(1)  
**Стабильность:** нестабильна  
**Примечание:** проста в реализации, но медленна для больших массивов.

---

### 2. Bubble Sort — `BubbleSort.java`

**Определение:**  
Сортировка пузырьком — метод, при котором элементы многократно сравниваются попарно и меняются местами, если нарушен порядок.

**Как работает:**
1. Проходить по массиву, сравнивая соседние элементы.  
2. Менять их местами, если левый больше правого.  
3. Повторять проходы, пока обменов не останется.

**Временная сложность:** O(n²)  
**Пространственная сложность:** O(1)  
**Стабильность:** стабильна  
**Примечание:** неэффективна при больших объёмах данных, подходит для демонстрации принципов сортировки.

---

### 3. Insertion Sort — `insertion_sort.py`

**Определение:**  
Сортировка вставками — алгоритм, который строит отсортированную последовательность, вставляя элементы на правильное место.

**Как работает:**
1. Считать первый элемент отсортированным.  
2. Для каждого следующего найти корректную позицию в отсортированной части.  
3. Сдвинуть элементы и вставить текущий элемент.

**Временная сложность:** O(n²)  
**Пространственная сложность:** O(1)  
**Стабильность:** стабильна  
**Примечание:** эффективна для небольших или почти отсортированных массивов.

---

### 4. Merge Sort — `merge_sort.cpp`

**Определение:**  
Сортировка слиянием — рекурсивный алгоритм, который делит массив на части, сортирует их и объединяет обратно в отсортированный список.

**Как работает:**
1. Разделить массив пополам.  
2. Рекурсивно отсортировать обе части.  
3. Слить две отсортированные половины в один массив.

**Временная сложность:** O(n log n)  
**Пространственная сложность:** O(n)  
**Стабильность:** стабильна  
**Примечание:** производительна и предсказуема, но требует дополнительной памяти.

---

### 5. Shell Sort — `ShellSort.java`

**Определение:**  
Сортировка Шелла — улучшение сортировки вставками с применением переменного шага (gap) между сравниваемыми элементами.

**Как работает:**
1. Установить шаг `gap = n / 2`.  
2. Выполнять сортировку вставками для элементов с данным шагом.  
3. Уменьшать `gap` и повторять до `gap = 1`.

**Временная сложность:** O(n log² n)  
**Пространственная сложность:** O(1)  
**Стабильность:** нестабильна  
**Примечание:** быстрее, чем простые O(n²) алгоритмы, но хуже современных методов сортировки.

---

### 6. Quick Sort — `quick_sort.py`

**Определение:**  
Быстрая сортировка — алгоритм, основанный на принципе разделения массива относительно опорного элемента (pivot).

**Как работает:**
1. Выбрать опорный элемент.  
2. Разделить массив на две части — меньше и больше pivot.  
3. Рекурсивно отсортировать обе части.  

**Временная сложность:** O(n log n)  
**Пространственная сложность:** O(log n)  
**Стабильность:** нестабильна  
**Примечание:** одна из самых эффективных сортировок для больших объёмов данных.

---

### 7. Heap Sort — `heap_sort.cpp`

**Определение:**  
Пирамидальная сортировка использует структуру max-heap для упорядочивания элементов по возрастанию.

**Как работает:**
1. Построить max-heap из исходного массива.  
2. Извлечь максимум (корень), переместить его в конец массива.  
3. Восстановить свойство кучи и повторить.  

**Временная сложность:** O(n log n)  
**Пространственная сложность:** O(1)  
**Стабильность:** нестабильна  
**Примечание:** не требует дополнительной памяти и даёт стабильную по времени производительность.

---

### 8. Linear Search — `linear_search.py`

**Определение:**  
Линейный поиск проверяет каждый элемент массива, пока не найдёт нужный или не достигнет конца.

**Как работает:**
1. Последовательно сравнивать каждый элемент с искомым значением.  
2. При совпадении вернуть индекс.  
3. Если элемент не найден — вернуть -1.

**Временная сложность:** O(n)  
**Пространственная сложность:** O(1)  
**Примечание:** простейший метод, работающий с неотсортированными данными.

---

### 9. Binary Search — `binary_search.cpp`

**Определение:**  
Двоичный поиск работает с отсортированным массивом, сокращая диапазон поиска вдвое на каждом шаге.

**Как работает:**
1. Установить границы `left` и `right`.  
2. Найти середину `mid`.  
3. Сравнить `arr[mid]` с ключом и выбрать нужную половину массива.  
4. Повторять, пока элемент не будет найден или диапазон не станет пустым.

**Временная сложность:** O(log n)  
**Пространственная сложность:** O(1)  
**Примечание:** быстрый поиск, но требует предварительной сортировки данных.

---

### 10. Interpolation Search — `InterpolationSearch.java`

**Определение:**  
Интерполяционный поиск — усовершенствованный метод для отсортированных массивов с равномерным распределением данных.

**Как работает:**
1. Рассчитать предполагаемую позицию элемента по формуле интерполяции.  
2. Сравнить значение с искомым ключом.  
3. Сузить диапазон поиска и повторить.

**Временная сложность:** O(log log n)  
**Пространственная сложность:** O(1)  
**Примечание:** эффективен только при равномерных данных.

---

### 11. Fibonacci Search — `fibonacci_search.py`

**Определение:**  
Поиск по Фибоначчи использует последовательность чисел Фибоначчи для деления диапазона поиска.

**Как работает:**
1. Найти минимальное число Фибоначчи, большее длины массива.  
2. Сравнить элемент по индексу, вычисленному из чисел Фибоначчи.  
3. Сузить диапазон и повторить до нахождения ключа.

**Временная сложность:** O(log n)  
**Пространственная сложность:** O(1)  
**Примечание:** похож на бинарный поиск, но иногда проще реализуется при ограничениях по арифметике.

---

## Таблица характеристик

| Алгоритм | Тип | Врем. сложность | Простр. сложность | Стабильность |
|-----------|------|-----------------|-------------------|---------------|
| Selection Sort | Сортировка | O(n²) | O(1) | Нет |
| Bubble Sort | Сортировка | O(n²) | O(1) | Да |
| Insertion Sort | Сортировка | O(n²) | O(1) | Да |
| Merge Sort | Сортировка | O(n log n) | O(n) | Да |
| Shell Sort | Сортировка | O(n log² n) | O(1) | Нет |
| Quick Sort | Сортировка | O(n log n) | O(log n) | Нет |
| Heap Sort | Сортировка | O(n log n) | O(1) | Нет |
| Linear Search | Поиск | O(n) | O(1) | — |
| Binary Search | Поиск | O(log n) | O(1) | — |
| Interpolation Search | Поиск | O(log log n) | O(1) | — |
| Fibonacci Search | Поиск | O(log n) | O(1) | — |

---

## Автор
**Александр Руденко**  

Группа УИБО-14-24
